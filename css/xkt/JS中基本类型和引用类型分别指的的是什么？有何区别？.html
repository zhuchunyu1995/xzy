<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>JS中基本类型和引用类型分别指的的是什么？有何区别？</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : 'https://ptteng.github.io/PPT/css/reveal/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h4>JS中基本类型和引用类型分别指的的是什么？有何区别？</h4>

        

            <p style="text-align: center;font-size:25px;">分享人：朱春雨</p>
        </section>
        <section>
            <p>目录</p>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>
        <section>
            <h3>1.背景介绍</h3>
        </section>
        <section style="font-size: 23px;">
                <h3>JS基本类型</h3>
            <p>
               
                字符串可以是单引号或双引号中的任意文本。
                
              
            </p>
        </section>
    


     <section section style="font-size: 23px;">
        <p style="text-align: left">
            数字(Number)<br>
            全局方法 Number() 转换成数字
            <img src="./img/5.png">
        </p>
 </section>

<section section style="font-size: 23px;">
    <p style="text-align: left">
        布尔只有两个值：true、false。<br>
undefined，null，NAN,""，0，false为false，其余全为true
空数组是true，对象也是true。
    </p>
</section>

<section section style="font-size: 23px;">
    <p style="text-align: left">
      
在js中写布尔和判断相关的代码时，都会要求遵循一定的编码规范：<br><br>

用绝对等于===判断来代替等于==<br>
能用绝对等于的地方永远用绝对等于而不要用等于==<br>
因为绝对等于===会先判断数据类型，数据类型不同直接返回false<br>
而等于==会先进行数据转换<br>
同理推荐使用不绝对等于!==而不是不等于!=<br><br>
例如<br>
 console.log('0'==0);//true<br>
  console.log('0'===0);//false<br><br>

基本上就是<br>
undefined等于undefined undefined等于null<br>
NaN不等于任何 甚至不等于另一个NaN<br>


    </p>
</section>


<section section style="font-size: 23px;">
    <p style="text-align: left">
        空
         类型只有一个值null。表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。
         在 JS 中 null 表示 "什么都没有"。
         null是一个只有一个值的特殊类型。表示一个空对象引用。
        <br><br>

        未定义

        Undefined类型也只有一个值，当声明的变量还未被初始化时，变量的默认值为undefined。
        一个没有值的变量会返回 undefined。
    </p>
</section>





<section section style="font-size: 23px;">
    <p style="text-align: left">
        Symbol 
生成一个全局唯一的值。

特点是唯一性，即使是用同一个变量生成的值也不相等。

    </p>
    <img src="./img/11.png">
</section>




<section section style="font-size: 23px;text-align: left;">
   
 
        <h3>引用数据类型：</h3>

        对象(Object)
        分为键和值<br>
        var name=
        {
        one : "53岁"；  one是键，53岁是值
        
        }<br>
        可以在对象里设置函数，引用函数需要加（），不加引用函数表达式，对象是全局属性<br><br>
        数组<br>
        数组下标是基于零的，所以第一个是 [0]，第二个 [1]，以此类推。可以用for循环获取下标
   
  
</section>



<section section style="font-size: 21px;text-align: left">
    

    <h3>函数</h3>

     声明一个函数 function one() {<br>
        //函数执行代码<br>
     }
引用方式 one()  <br><br>
匿名函数自执行<br>
   (function() {<br>
    //函数执行代码 <br>
})(); 打开网页自动执行<br><br>
匿名函数放在变量中<br>
    var one=function() {<br>
        //函数执行代码<br>
}
调用one()<br><br>
函数放在数组中<br> var one=[]; <br>one[0]=function() {<br>//函数执行代码} 调用one[0]()<br><br>
函数在事件调用时不要写括号，比如one(),要这么写one


</section>

<section section style="font-size: 21px;text-align: left">
函数传参<br>
function one(形参1,形参2){<br>
    //函数执行代码<br>
}<br>
one(实参1,实参2);//调用时传参<br>
<img src="./img/10.png">


</section>

<section section style="font-size: 21px;text-align: left">
    函数返回值即函数执行之后的返回结果。<br>
    所有函数都会有函数返回值,函数执行后一定会返回一个结果，如果没有定义默认返回undefined；
    在函数中，return后定义返回值；return之后的代码就不会再执行了,只能用于函数中，用在其他地方会报错 <br>
    <img src="./img/19.png">
    </section>

        <section>
            <h3>2.知识剖析</h3>
        </section>
        <section>
                <p>引用类型与基本类型的区别</p>
        </section>
        <section style="font-size: 24px;text-align: left;">
        引用类型是存放在堆内存中的对象，变量是保存的在栈内存中的一个指针（保存的是堆内存中的引用地址），这个指针指向堆内存。
        引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象
        栈内存主要用于存储各种基本类型的变量，包括Boolean、Number、String、Undefined、Null，以及对象变量的指针，这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。
        而堆内存主要负责像对象Object这种变量类型的存储
        </section>
      

        <section style="font-size: 24px;text-align: left;">
         <p>栈内存中的变量一般都是已知大小或者有范围上限的，算作一种简单存储。
         而堆内存主要负责像对象Object这种变量类型的存储，堆内存存储的对象类型数据对于大小这方面，一般都是未知的。</p>
        </section>




        <section style="font-size: 24px;text-align: left;">
           <p> 栈内存

            初始栈内存只有a，栈内存添加b，b复制a。此时b是10，栈内存b保存了另一个值，但是并不影响a的值。</p>
            <img src="./img/14.png">
        </section>
        <section style="font-size: 24px;text-align: left;">

            new关键字生成的对象都是存在于堆内存中的,

           变量 a 存在于栈内存中，他的值是一个指针，这个指针指向堆内存中的一个对象！
      
            <img src="./img/15.png">
            </section>

            <section style="font-size: 24px;text-align: left;">
                引用类型变量的值是指针，指向堆内存中的一块地址。
              
               
                <img src="./img/16.png">
            </section>

            <section style="font-size: 24px;text-align: left;">
                <img src="./img/17.png">
            </section> 
            
            <section style="font-size: 24px;text-align: left;">
                <p>one1在栈内存中，值指向堆内存，one2等于one1，它们的指针指向一个堆内存对象，所以one1也可以访问one2</p>
                <img src="./img/18.png">
            </section>
            


            <section style="font-size: 24px;text-align: left;">
                
                
                
                 var a = [1,2,3,4,5];<br>
                    var b = a;//传给变量的数据是引用类型的，会存储在堆中；<br>
                    var c = a[0];//把对象中的属性/数组中的数组项赋值给变量，这时变量C是基本数据类型，存储在栈内存中；改变栈中的数据不会影响堆中的数据<br>
                    console.log(b);//1,2,3,4,5<br>
                    console.log(c);//1<br>
                    //改变数值 <br>
                    b[4] = 6;<br>
                    c = 7;<br>
                    console.log(a[4]);//6<br>
                    console.log(a[0]);//1<br>
                a在栈内存，b等于a，b复制了一份a的数组，在同一个栈内，所以修改b，a也会根据地址回到a堆中修改<br>
                c直接在栈中修改，不能指向a堆内存中。<br>
            </section>






  <section style="font-size: 21px;text-align: left;">
    1、声明变量时内存分配不同<br>
    　原始类型：在栈中，因为占据空间是固定的，可以将他们存在较小的内存中-栈中，便于迅速查询变量的值
    　引用类型：存在堆中，栈中存储的变量，只是用来查找堆中的引用地址, 因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响<br><br>
    2、不同的内存分配带来不同的访问机制<br>
        在JS中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是按引用访问。
        而原始类型的值则是可以直接访问到的。<br><br>
    3、复制变量时的不同<br>
     1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。<br>
    2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针<br><br>
    4、参数传递的不同（把实参复制给形参的过程）<br>
    原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。<br>
    引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点要时刻铭记在心！<br>
    因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。<br>
            </section>




        <section>
            <h3>3.常见问题</h3>
        </section>
        
        <section>
            <h3>4.解决方案</h3>
        </section>

        <section>
            <h3>5.编码实战</h3>
        </section>

        <section>
            <h3>6.扩展思考</h3>
        </section>

        <section>
            <h3>7.参考文献</h3>
        </section>

        <section>
            <p style="font-size: 12px;">
            https://blog.csdn.net/qq_34569497/article/details/95379260#1.%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%A3%B0%E6%98%8E%E5%8F%8A%E8%B0%83%E7%94%A8
            </p>
        </section>
        <section>
            <h3>8.更多讨论</h3>
        </section>

        <section>
            <h4>感谢观看</h4>
            <p>
                
            </p>
        </section>
    </div>
</div>
<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>
    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触
    Reveal.initialize({
        history: true,
        dependencies: [
            {src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js'},
            {src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js'},
            {src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true},
            {
                src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            }
        ]
    });
</script>
</body>
</html>