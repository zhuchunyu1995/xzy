<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>JS中基本类型和引用类型分别指的的是什么？有何区别？</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : 'https://ptteng.github.io/PPT/css/reveal/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h4>JS中基本类型和引用类型分别指的的是什么？有何区别？</h4>

        

            <p style="text-align: center;font-size:25px;">分享人：朱春雨</p>
        </section>
        <section>
            <p>目录</p>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>
        <section>
            <h3>1.背景介绍</h3>
        </section>
        <section style="font-size: 23px;">
                <h3>JS基本类型</h3>
            <p style="text-align: left">
               
                字符串（String） length 来计算字符串的长度：var name= “buff”； var 创建一个变量，变量名为 name， "buff"为字符串 字符串可以是单引号或双引号中的任意文本。
                全局方法String() 可以将数字转换为字符串。String()
                该方法可用于任何类型的数字，字母，变量，表达式
                toString()也是有同样的效果，不能转Null，undefined两种类型 
                <img src="./img/1.png">
            </p>
        </section>
        <section section style="font-size: 23px;">
            
                <img src="./img/2.png">
            
         </section>


         <section section style="font-size: 23px;">
            <p style="text-align: left">
                自动转换类型<br>
                5 + null    // 返回 5         null 转换为 0<br>
                "5" + null  // 返回"5null"   null 转换为 "null"<br>
                "5" + 1     // 返回 "51"      1 转换为 "1" <br>
                "5" - 1     // 返回 4         "5" 转换为 5<br>
            </p>
     </section>




     <section section style="font-size: 23px;">
        <p style="text-align: left">
            数字(Number)
            全局方法 Number() 可将日期转换为数字。
             d = new Date();
             Number(d)  
             <img src="./img/3.png">    
             <img src="./img/4.png">
        </p>
 </section>
 <section section style="font-size: 23px;">
         <img src="./img/5.png">
</section>

<section section style="font-size: 23px;">
    <p style="text-align: left">
        布尔(Boolean)只有两个值：true、false。
undefined，null，NAN,""，0，false为false，其余全为true
空数组是true，对象也是true，一般用空数组length判断数组有没有数据
<img src="./img/6.png">
    </p>
</section>
<section section style="font-size: 23px;">
    <img src="./img/7.png">
</section>

<section section style="font-size: 23px;">
    <p style="text-align: left">
        写法规范
在js中写Boolean和判断相关的代码时，都会要求遵循一定的编码规范：

用===判断来代替==，能用全等的地方永远用全等而不要用==
因为===会先判断数据类型，数据类型不同直接返回false
而==会先进行数据转换
同理推荐使用!==而不是!=
例如
 console.log('0'==0);//true
  console.log('0'===0);//false

基本上就是
undefined等于undefined undefined等于null
NaN不等于任何 甚至不等于另一个NaN
除了上述类型有数字优先转数字
都是对象保证引用同一对象，否则将对象转ToPrimitive（抽象操作）再对比
在if中判断字符串和数组有没有值，要采用简写
写成if(val)和if(arr.length)
而不是if(val!=='')和if(arr.length>0)
    </p>
</section>

<section section style="font-size: 23px;">
    <p style="text-align: left">
        对空（Null）

        Null类型只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。
        在 JS 中 null 表示 "什么都没有"。
        null是一个只有一个值的特殊类型。表示一个空对象引用。
        
        用 typeof 检测 null 返回是object。
        可以设置为 null 来清空对象:
        
        var person = null;
        <img src="./img/8.png"><br>
        var person = undefined; 变量可以通过设置 undefined 来清空。
        <img src="./img/9.png">
    </p>
</section>


<section section style="font-size: 23px;">
    <p style="text-align: left">
        未定义（Undefined）

        Undefined类型也只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。
        typeof 一个没有值的变量会返回 undefined。
        <img src="./img/10.png">
    </p>
</section>


<section section style="font-size: 23px;">
    <p style="text-align: left">
        Symbol 
生成一个全局唯一的值。

Symbol 数据类型的特点是唯一性，即使是用同一个变量生成的值也不相等。

    </p>
    <img src="./img/11.png">
</section>




<section section style="font-size: 23px;">
    <p style="text-align: left">
 
        <h3>引用数据类型：</h3>

        对象(Object)
        对象分为键和值
        var name=
        {
        age : "53岁"；  age是键，53岁是值
        
        可以在对象里设置函数，引用函数需要加（），不加引用函数表达式，对象是全局属性
        }
        
        数组(Array)
        数组下标是基于零的，所以第一个是 [0]，第二个是 [1]，以此类推。可以用for循环来实现引用整个数组
    </p>
    <img src="./img/12.png">
  
</section>



<section section style="font-size: 21px;text-align: left">
    
 
        <h3>函数(Function)</h3>

        function 声明一个函数,可以在函数内引用，可以在函数中声明<br>
        JS中函数有两种命名方式<br>

        1、一种是声明式<br>
        声明式会导致函数提升，function会被解释器优先编译。即我们用声明式写函数，可以在任何区域声明，不会影响我们调用 function XXX(){}<br>
        一种是函数表达式<br>
        函数表达式中的function不会出现函数提升。而是JS解释器逐行解释，因此如果调用在函数表达式之前，则会调用失败<br>
        var k = function(){}<br>
        fn1();<br>
        function fn1(){}    可以正常调用<br>
        
        fn2();<br>
        var fn2 = function(){}    无法调用<br>
        
        对函数表达式加上()，是可以直接调用的<br>
        但是如果是对声明式的后部加上()则是会被编译器忽略。v
        
        var fn2 = function(){}();    对，就是这样<br>
        function fn1(){}();           会被忽略v

        
        而平常的function(){}则是一种声明式，如果加上()括号后，则会被编译器认为是函数表达式，（加上+-号都可以），从而可以用()来直接调用<br>
        （function fn1(){}）();<br>
        
        
        叹号后面跟函数!function<br>
        和加号后面跟函数+function<br>
        都是跟(function(){})();这个函数是一个意思，都是告诉浏览器自动运行这个匿名函数的，因为!+()这些符号的运算符是最高的，所以会先运行它们后面的函数<br>
</section>


        <section>
            <h3>2.知识剖析</h3>
        </section>
        <section>
                <p>引用类型与基本类型的区别</p>
        </section>
        <section style="font-size: 24px;text-align: left;">
        引用类型是存放在堆内存中的对象，变量是保存的在栈内存中的一个指针（保存的是堆内存中的引用地址），这个指针指向堆内存。
        引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象
        栈内存主要用于存储各种基本类型的变量，包括Boolean、Number、String、Undefined、Null，**以及对象变量的指针，这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。
        而堆内存主要负责像对象Object这种变量类型的存储
        </section>
      

        <section style="font-size: 24px;text-align: left;">
         <p>栈内存中的变量一般都是已知大小或者有范围上限的，算作一种简单存储。
         而堆内存主要负责像对象Object这种变量类型的存储，堆内存存储的对象类型数据对于大小这方面，一般都是未知的，（所以这大概也是为什么null作为一个object类型的变量却存储在栈内存中的原因）。</p>
            <img src="./img/13.png">
        </section>




        <section style="font-size: 24px;text-align: left;">
           <p> 栈内存

            初始栈内存只有a，栈内存添加b，b复制a。此时b是10，栈内存b保存了另一个值，但是并不影响a的值。</p>
            <img src="./img/14.png">
        </section>
        <section style="font-size: 24px;text-align: left;">

            new关键字生成的对象都是存在于堆内存中的

            var a = new String('桔子桑')；变量 a 存在于栈内存中，他的值是一个指针，这个指针指向堆内存中的一个对象！
            <img src="./img/15.png">
            </section>

            <section style="font-size: 24px;text-align: left;">

                普通变量的值类型是基本数据类型，指向栈内存中的一块地址；
                引用类型变量的值是指针，指向堆内存中的一块地址。
                <img src="./img/16.png">
            </section>

            <section style="font-size: 24px;text-align: left;">
                <img src="./img/17.png">
            </section> 
            
            <section style="font-size: 24px;text-align: left;">
                <p>one1在栈内存中，值指向堆内存，one2等于one1，它们的指针指向一个堆内存对象，所以one1也可以访问one2</p>
                <img src="./img/18.png">
            </section>
            <section style="font-size: 24px;text-align: left;">
                <img src="./img/19.png">
            </section>


            <section style="font-size: 24px;text-align: left;">
                下面这个例子，a在栈内存，b等于a，b复制了一份a的数组，在同一个栈内，所以修改b，a也会根据地址回到a堆中修改<br>

                c直接在栈中修改，不能指向a堆内存中。<br>
                
                
                 var a = [1,2,3,4,5];<br>
                    var b = a;//传址 ,对象中传给变量的数据是引用类型的，会存储在堆中；<br>
                    var c = a[0];//传值，把对象中的属性/数组中的数组项赋值给变量，这时变量C是基本数据类型，存储在栈内存中；改变栈中的数据不会影响堆中的数据<br>
                    alert(b);//1,2,3,4,5<br>
                    alert(c);//1<br>
                    //改变数值 <br>
                    b[4] = 6;<br>
                    c = 7;<br>
                    alert(a[4]);//6<br>
                    alert(a[0]);//1<br>
            </section>






  <section style="font-size: 21px;text-align: left;">
    1、声明变量时内存分配不同<br>
    　*原始类型：在栈中，因为占据空间是固定的，可以将他们存在较小的内存中-栈中，这样便于迅速查询变量的值
    　*引用类型：存在堆中，栈中存储的变量，只是用来查找堆中的引用地址。
    　   这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响<br><br>
    2、不同的内存分配带来不同的访问机制<br>
        在JS中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。
        而原始类型的值则是可以直接访问到的。<br><br>
    3、复制变量时的不同<br>
     1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。<br>
    2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针<br><br>
    4、参数传递的不同（把实参复制给形参的过程）<br>
    原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。<br>
    引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点要时刻铭记在心！<br>
    因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。<br>
            </section>




        <section>
            <h3>3.常见问题</h3>
        </section>
        
        <section>
            <h3>4.解决方案</h3>
        </section>

        <section>
            <h3>5.编码实战</h3>
        </section>

        <section>
            <h3>6.扩展思考</h3>
        </section>

        <section>
            <h3>7.参考文献</h3>
        </section>
        <section>
            <h3>8.更多讨论</h3>
        </section>

        <section>
            <h4>感谢观看</h4>
            <p>
                
            </p>
        </section>
    </div>
</div>
<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>
    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触
    Reveal.initialize({
        history: true,
        dependencies: [
            {src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js'},
            {src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js'},
            {src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true},
            {
                src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            }
        ]
    });
</script>
</body>
</html>